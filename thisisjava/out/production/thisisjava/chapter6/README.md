이 글은 '이것이 자바다' 책의 내용을 읽고 정리한 것 입니다.

## 1\. 클래스 선언

```
public class 클래스이름 {

}
```

일반적으로 소스파일당 하나의 클래스를 선언한다.

두 개 이상의 클래스가 선언된 소스파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다. 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다. 가급적이면 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋다.

주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.

## 2\. 객체 생성

```
클래스 변수;
변수 = new 클래스();

클래스 변수 = new 클래스();
```

new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다. 객체는 메모리 힙(heap) 영역에 생성된다.

new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.

## 3\. 클래스의 구성 멤버

필드(Field) 생성자(Constructor), 메소드(Method)

생성자

오버로딩 : 타입, 개수, 순서를 다르게

다른 생성자 호출 this() : 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄에서만 허용됨

메소드

매개 변수의 수를 모를 경우

```
// 매개 변수를 배열 타입으로 선언
int sum1(int[] values) { }

// 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법
// 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
int sum2(int ... values) { }

int[] arr = {1, 2, 3};
int result = sum2(arr);
int result = sum2(new int [] {1, 2, 3, 4, 5});
int result = sum2(1, 2, 3, 4);
```

메소드 오버로딩

매개 변수의 타입, 개수, 순서 중 하나가 달라야 한다. 주의 리텁 타입만 다르고 매개 변수가 동일하면 이것은 오버로딩이 아니다. 리턴 타입은 자바 가상 기계가 메소드를 선택할 때 아무런 도움을 주지 못하기 때문이다.

JVM은 매개값의 타입을 보고 메소드를 선택한다.

인스턴스 메소드는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.

## 4\. 정적 멤버와 static

클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

```
public class 클래스 {
	//정적 필드
    static 타입 필드;
    
    //정적 메소드
    static 리턴 타입 메소드( ) { }
}
```

클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

정적 초기화 블록

정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다.

하지만 계산이 필요한 초기화 작업 등의 이유로 초기화 작업을 위한 정적 블록(static block)을 제공한다.

```
static {

}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다. 정적 블록은 클래스 내부에 여러개가 선언되어도 상관없다. 선언된 순서대로 실행된다.

```
public class Television {
	static String company = "Samsung";
    static String model = "LCD";
    static String info;
    
    static {
    	info = company + "-" + model;
    }
}
```

주의할 점은 객체가 없어도 실행된다는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this 키워드도 사용할 수 없다.

## 5\. final 필드와 상수

final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정 할 수 없다는 것이다.

```
final 타입 필드 [= 초기값];
```

초기화는 필드 선언, 생성자에서 값을 주는 방법 2가지 이다.

상수(static final)

불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러 가지 값으로 초기화될 수 없기 때문에 static 이면서 final 이어야 한다.

## 6\. 접근 제한자

| 접근 제한 | 적용 대상 | 접근할 수 없는 클래스 |
| --- | --- | --- |
| public | 클래스, 필드, 생성자, 메소드 | 없음 |
| protected | 필드, 생성자, 메소드 | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스 |
| private | 필드, 생성자, 메소드 | 모든 외부 클래스 |

## 7\. 어노테이션

어노테이션(Annotation)은 메타데이터(metadata)라고 볼 수 있다.

애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다. 어노테이션은 다음과 같은 형태로 작성된다.

```
@AnnotationName

public @interface AnnotationName {
	타입 elementName() [default 값];
}
```

1\. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공

2\. 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공

3\. 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

어노테이션은 엘리먼트를 멤버로 가질 수 있다. 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

기본 데이터 타입이나 String, 열거 타입, class 타입, 그리고 이들의 배열 타입을 사용할 수 있다.

```
@AnnotationName(elementName1 = "값1", elementName2 = "3)
```

어노테이션 적용 대상

| ElementType 열거 상수 | 적용 대상 |
| --- | --- |
| TYPE | 클래스, 인터페이스, 열거 타입 |
| ANNOTATION\_TYPE | 어노테이션 |
| FIELD | 필드 |
| CONSTRUCTOR | 생성자 |
| METHOD | 메소드 |
| LOCAL\_VARIABLE | 로컬 변수 |
| PACKAGE | 패키지 |

어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다. @Target의 기본 엘리먼트인 value는 ElementType 배열을 값으로 가진다. 이것은 어노테이션이 적용될 대상을 복수개로 지정하기 위해서이다.

```
@Target(ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})
public interface AnnotationName{
}

@AnnotationName
public class ClassName {
	@AnnotationName
    private String fieldName;
    
    //@AnnotationName (x)	@Target에 CONSTRUCT가 없어 생성자는 적용 못함
    public ClassName() { }
    
    @AnnotationName
    public void methodName() { }
}
```

어노테이션 유지 정책

```
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationName {
}
```

| RetentionPolicy 열거 상수 | 설명 |
| --- | --- |
| SOURCE | 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있으며, 바이트 코드 파일에는 정보를 남기지 않는다. |
| CLASS | 바이크 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다. |
| RUNTIME | 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다. |

\*리플렉션(Reflection)이란 런타임 시에 클래스의 메타 정보를 얻는 기능을 말한다.

런타임 시 어노테이션 정보 사용하기

어노테이션 자체는 아무런 동작을 가지지 않는 단지 표식일 뿐이지만, 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.

| 리턴 타입 | 메소드명(매개변수) | 설명 |
| --- | --- | --- |
| Field\[\] | getFields() | 필드 정보를 Field 배열로 리턴 |
| Constructor\[\] | getCosntructors() | 생성자 정보를 Constructor 배열로 리턴 |
| Method\[\] | getDeclaredMethods() | 메소드 정보를 Method 배열로 리턴 |