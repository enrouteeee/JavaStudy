이 글은 '이것이 자바다' 책의 내용을 읽고 정리한 것 입니다.

## 1.  인터페이스

객체의 사용 방법을 정의한 타입으로 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.

```
public interface 인터페이스명 {
	...
}
```

클래스는 필드, 생성자, 메소드를 구성 멤버로 가지는데 비해, 인터페이스는 상수와 메소드만을 구성 멤버로 가진다.

인터페이스는 객체로 생성할 수 없기 때문에 생성자를 가질 수 없다.

```
interface 인터페이스명 {
	//상수
   	타입 상수명 = 값;
    //추상 메소드
    타입 메소드명(매개변수, ...);
    //디폴트 메소드
    default 타입 메소드명(매개변수, ...){...}
    //정적 메소드
    static 타입 메소드명(매개변수) {...}
}
```

상수 필드 : 선언된 필드는 모두 public static final 의 특성을 갖는다. public, static, final 을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.

추상메소드 : 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 그렇기 때문에 실행 블록이 필요 없다. 모두 public abstract 의 특성을 갖기 때문에 public abstract 을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.

디폴트 메소드 : 인터페이스에 선언되지만 사실은 객체(구현 객체)가 가지고 있는 인스턴스 메소드라고 생각해야 한다. 인터페이스에서 바로 사용할 수 없고, 구현 객체가 있어야 사용할 수 있다. public 생략해도 된다.

정적 메소드 : 디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능하다. public 생략해도 된다.

## 2\. 인터페이스 구현

개발코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다. 이러한 객체를 인터페이스의 구현 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.

```
public class 구현클래스명 implements 인터페이스명 {
	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

주의 할 점으로 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 public 보다 더 낮은 접근 제한으로 작성할 수 없다.

#### 익명 구현 객체

구현 클래스를 만들어 사용하는 것이 일반적이고, 클래스를 재사용할 수 있기 때문에 편리하지만, 일회성 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다. 자바는 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데, 그것이 익명 구현 객체이다.

UI 프로그래밍에서 이벤트를 처리하기 위해, 임시 작업 스레드를 만들기 위해 익명 구현 객체를 많이 활용한다.

자바 8에서 지원하는 람다식은 인터페이스의 익명 구현 객체를 만든다.

```
인터페이스 변수 = new 인터페이스() {
	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언
};
```

중괄호 안에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야한다. 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다.

#### 다중 인터페이스 구현 클래스

객체는 다수의 인터페이스 타입으로 사용할 수 있다.

```
public class 구현클래스명 implements 인터페이스A, 인터페이스B {
	//A 추상 메소드의 실체 메소드
    //B 추상 메소드의 실체 메소드
}
```

## 3\. 타입 변환과 다형성

상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념적 차이점은 있지만 둘 다 다형성을 구현하는 기술이다.

## 4\. 인터페이스 상속

인터페이스도 다른 인터페이스를 상속할 수 있다. 인터페이스는 클래스와 달리 다중 상속을 허용한다.

```
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2 {

}
```

하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만이 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.

## 5\. 디폴트 메소드와 인터페이스 확장

인터페이스에서 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다. 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 이전에 개발한 구현 클래스를 그대로 사용할 수 있으면서 새롭게 개발하는 클래스는 디폴트 메소드를 활용할 수 있다.

#### 디폴트 메소드가 있는 인터페이스 상속

디폴트 메소드를 단순히 상속만 받는다.

디폴트 메소드를 재정의해서 실행 내용을 변경한다.

디폴트 메소드를 추상 메소드로 재선언한다.