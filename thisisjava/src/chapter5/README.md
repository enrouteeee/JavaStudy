이 글은 '이것이 자바다' 책의 내용을 읽고 정리한 것 입니다.

## 1\. 데이터 타입 분류

자바의 데이터 타입에는 크게 기본타입(primitive type)과 참조 타입(reference type)으로 분류된다.

참조 타입이란 객체(Object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말한다.

기본타입으로 선언된 변수와 참조 타입으로 선언된 변수의 차이점은 저장되는 값이 무엇이냐이다. 기본 타입은 실제 값을 변수 안에 저장하지만, 참조 타입은 메모리의 번지를 값으로 갖는다. 번지를 통해 객체를 참조한다는 뜻에서 참조 타입이라고 부른다.

## 2\. 메모리 사용 영역

JVM이 시작되면 JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 메소드 영역, 힙 영역, JVM 스택 영역으로 구분해서 사용한다.

#### A. 메소드(Method) 영역

코드에서 사용되는 클래스(~.class)들을 클래스 로더로 읽어 클래스별로 런타임 상수풀(runtime constant pool), 필드(field) 데이터, 메소드(method) 데이터, 메소드 코드, 생성자(constructor) 코드 등을 분류해서 저장한다. 메소드 영역은 JVM이 시작될 때 생성되고 모든 스레드가 공유하는 영역이다.

#### B. 힙(Heap) 영역

객체와 배열이 생성되는 영역이다. 힙 영역에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조된다. 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 이것을 쓰레로 취급하고 쓰레기 수집기(Garbage Collector)를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거한다.

#### C. JVM스택(Stack) 영역

각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다. 자바 프로그램에서 추가적으로 스레드를 생성하지 않았다면 main 스레드만 존재하므로 JVM 스택도 하나이다.

JVM 스택은 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다. 예외 발생 시 printStackTrace() 메소드로 보여주는 Stack Trace의 각 라인은 하나의 프레임을 표현한다.

프레임 내부에는 로컬 변수 스택인 있는데, 기본 타입 변수와 참조 타입 변수가 추가(push), 제거(pop)된다. 변수가 이 영역에 생성되는 시점은 초기화가 될 때, 즉 최초로 변수에 값이 저장될 때이다. 변수는 선언된 블록 안에서만 스택에 존재하고 블록을 벗어나면 스택에서 제거된다.

기본타입 변수는 스택 영역에 값을 직접 갖고 있지만, 참조 타입 변수는 값이 아니라 힙 영역이나 메소드 영역의 객체 주소를 가진다.

## 3\. 참조 변수의 ==, != 연산

기본 타입 변수의 ==, != 연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 ==, != 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다. 참조 타입 변수의 값은 힙 영역의 객체 주소이므로 결국 주소 값을 비교하는 것이 된다. 동일한 주소 값을 갖고있다는 것은 동일한 객체를 참조한다는 의미이다.

## 4\. null과 NullPointerException

참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. null 값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 생성된다.

자바는 프로그램 실행 도중에 발생하는 오류를 예외(Exception)이라고 부른다. 예외는 사용자의 잘못된 입력으로 발생할 수도 있고, 프로그래머가 코드를 잘못 작성해서 발생할 수도 있다.

참조 타입 변수가 null을 가지고 있을 경우, 참조 타입 변수는 사용할 수 없다. null 값을 가지고 있는 참조 타입 변수를 사용하면 NullPointerException이 발생한다.

```
int[] intArray = null;
intArray[0] = 10;	// NullPointerException
```

## 5\. String 타입

자바는 문자열을 String 변수에 저장하기 때문에 String 변수를 우선 선언해야 한다.

String 변수에 문자열을 저장하려면 큰 따옴표로 감싼 문자열 리터럴을 대입하면 된다.

문자열을 String 변수에 저장한다는 말은 틀린 표현이다. 문자열이 직접 변수에 저장되는 것이 아니라, 문자열은 String객체로 생성되고 변수는 String 객체를 참조한다.

자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다.

```
String str1 = "자바";
String str2 = "자바";
```

하지만 new 연산자를 사용해서 직접 String 객체를 생성시킬 수도 있다. new 연산자는 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 한다. 이 경우 str1과 str2는 서로 다른 String객체를 참조한다.

```
String str1 = new String("자바");
String str2 = new String("자바");
```

동일한 String 객체이건 다른 String 객체이건 상관없이 문자열만 비교할 때에는 String 객체의 equals() 메소드를 사용해야 한다.

```
boolean result = str1.equals(str2);
```

## 6\. 배열 타입

배열은 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스(index)를 부여해 놓은 자료구조이다.

아래와 같이 2가지 선언 방법이 존재한다.

```
타입[] 변수;
타입 변수[];
```

배열 변수는 참조 변수에 속한다. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조하게 된다. 참조할 배열 객체가 없다면 배열 변수는 null값으로 초기화될 수 있다.

배열 항목에 저장될 값의 목록이 있다면, 아래와 같이 배열 객체를 만들 수 있다.

```
타입[] 변수 = {값0, 값1, 값2, 값3, ... };

타입[] 변수;
변수 = { 값0, 값1, 값2, 값3, ... };	//컴파일 에러
function( { 값0, 값1, 값2} );	//	컴파일 에러

타입[] 변수;
변수 = new 타입[] { 값0, 값1, 값2, 값3, ... };
function( new 타입[] { 값0, 값1, 값2, ... } );
```

값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 배열 객체를 생성시킬 수 있다.

```
타입[] 변수 = new 타입[길이];
```

배열의 길이는 배열 변수에 도트(.) 연산자를 붙이고 length를 적어주면 된다.

```
배열변수.length;
```

다차원 배열

```
타입[][] 변수 = new 타입[길이1][길이2];

타입[][] 변수 = new 타입[길이1][];
변수[0] = new 타입[길이2];
변수[1] = new 타입[길이3];
```

배열 복사

```
System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);

public class ArrayExample {
    public static void main(String[] args) {
        int[] intArr = {0, 10, 20, 30};
        int[] intArr2 = new int[6];
        System.arraycopy(intArr, 0, intArr2, 0, 4);

        for (int i : intArr2) {
            System.out.print(i+" ");
        }
    }
}
```

향상된 for문

자바5부터 배열 및 컬렉션 객체를 좀 더 쉽게 처리할 목적으로 향상된 for문을 제공한다. 향상된 for문은 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다.배열 및 컬렉션 항목의 개수만큼 반복하고, 자동으로 for문을 빠져나간다.

## 7\. 열거 타입

한정된 값만을 갖는 데이터 타입

열거타입도 참조 타입이기 때문에 null 값을 저장할 수 있음

열거 상수는 객체이다. 메소드 영역에 생성된 열거 상수가 해당 열거 객체를 각각 참조하게 된다.

열거 타입 변수는 스택 영역에 생성되어 열거 상수가 참조하는 객체와 같은 번지를 참조한다.

```
public enum 열거타입이름 { ... }

public enum Week { MONDAY, TUESDAY, WEDNESDAY, ... }	// 관례적으로 대문자와 _로 작성

열거타입 변수;
변수 = 열거타입.열거상수;
Week today;
today = Week.SUNDAY;
```

열거 객체의 메소드

| 리턴 타입 | 메소드(매개 변수) | 설명 |
| --- | --- | --- |
| String | name() | 열거 개체의 문자열을 리턴 |
| int | ordinal() | 열거 객체의 순번(0부터 시작)을 리턴 |
| int | compareTo() | 열거 객체를 비교해서 순번 차이를 리턴 |
| 열거 타입 | valueOf(String name) | 주어진 문자열의 열거 객체를 리턴 |
| 열거 배열 | values() | 모든 열거 객체들을 배열로 리턴 |